# module: trader.py
#
# Handle files generated by/for
# alesis micron/ion program decoder/encoder.
import subprocess, sys, os.path
from micronux import midi

ion_decoder_path = 'alesis/ion_program_decoder.pl'
default_prog = 'prog/default.txt'

# convert text line to name/value pair
def text_to_setting(line):
    line = line.strip()
    if line:
        if line.startswith('#'): # remove comments
            return False
        else:
            pair = line.split(':')
            # white spaces not allowed
            name = pair[0].replace(' ','_')
            # minus symbol not allowed
            if name.startswith('tracking_point_'):
                name = name.replace('-','m')
            value = pair[1].strip()
            return [name, value]
    else:
        return False

# convert name/value pair to text line
def setting_to_text(name, value):
    if name.startswith('tracking_point_'):
        name = name.replace('m','-')
    name = name.replace('_',' ')
    line = name+': '+value+'\n'
    return line

def syx_to_txt(file_path):
    cmd = [ion_decoder_path, '-b', file_path]
    result = subprocess.run(cmd)
    if result.returncode == 0:
        return True
    else:
        return False

### Read sysex into settings
def import_file(file_name):
    # convert syx to text
    prog = file_name
    if file_name.endswith('.syx'):
        if midi.fix_syx(file_name):
            if syx_to_txt(file_name):
                prog = file_name[:-3]+'txt'
            else:
                prog = default_prog
    elif not file_name.endswith('.txt'):
        print('File type must be .txt or .syx')
        prog = default_prog
    # read text file into a dict
    txt_file = open(prog)
    settings = {}
    print('loading '+prog)
    for line in txt_file:
        pair = text_to_setting(line)
        if pair:
            settings[pair[0]] = pair[1]
    txt_file.close()
    return settings


def export_file(file_name):
    return False


### Check the command line arguments
def startup(args):
    # without argument, load the default program
    prog = default_prog
    if len(args) > 1:
        # receive sysex option
        if args[1] == '-r':
            try:
                # check if port given
                args[2]
            except:
                print('Please specify a MIDI port')
                sys.exit(1)
            else:
                if midi.receive_sysex(args[2]):
                    prog = midi.cache
        # otherwise check if argument is a valid file
        elif os.path.isfile(args[1]):
            prog = args[1]
        else:
            print('Error opening "'+args[1]+'": File not found')
            sys.exit(1)
    return prog
