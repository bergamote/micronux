# module: trader.py
#
# Handle files generated by/for
# alesis micron/ion program decoder/encoder.
import subprocess, sys, os.path

ion_decoder_path = 'alesis/ion_program_decoder.pl'
cache = './prog/received.syx'

### Read sysex into settings
def import_file(file_name):
    # convert to text if sysex
    if file_name.endswith('.syx'):
        if fix_syx(file_name):
            file_name = fix_syx(file_name)
        else:
            # if not valid sysex load default
            file_name = 'prog/default.txt'

        cmd = [ion_decoder_path, '-b', file_name]
        result = subprocess.run(cmd)
        if result.returncode == 0:
            file_name = file_name[:-3]+'txt'
        else:
            # show program_decoder error
            sys.exit(1)
    elif not file_name.endswith('.txt'):
        print('File type must be .txt or .syx')
        sys.exit(1)

    txt_file = open(file_name)
    settings = {'file_name':file_name}
    print('### Loading settings from '+file_name)
    for line in txt_file:
        line = line.strip()
        if line:
            if not line.startswith('#'): # remove comments
                pair = line.split(':')
                name = pair[0].replace(' ','_')
                value = pair[1].strip()
                settings[name] = value
    txt_file.close()
    return settings

### Receive sysex and return settings
def receive_file(args):
    try:
        # check if port given
        args[2]
    except:
        print('Please specify a MIDI port (amidi -l).')
        sys.exit(1)
    else:
        # receive sysex with amidi
        midi_port = args[2]
        cmd = ['amidi', '-t', '3', '-p']
        cmd +=  [midi_port, '-r',cache]
        result = subprocess.run(cmd)
        if result.returncode == 0:
            settings = import_file(cache)
            return settings
        else:
            # show amidi error
            sys.exit(1)

### Check the command line arguments
def startup(args):
    if len(args) == 1:
        # Without argument, load the default program
        settings = import_file('prog/default.txt')
    else:
        # receive sysex option
        if args[1] == '-r':
            settings = receive_file(args)
        # otherwise check if argument is a valid file
        elif os.path.isfile(args[1]):
            settings = import_file(args[1])
        else:
            print('Error opening "'+args[1]+'": File not found')
            sys.exit(1)
    return settings

### Fix sysex file
# (if size isn't 434 bytes)
def fix_syx(path):
    size = os.path.getsize(path)
    error_msg = 'invalid syx file (should be 434 bytes)'
    if size != 434:
        if size < 434:
            print(error_msg)
            return False
        else:
            # if too long, check length between
            # f0 00 and f7, if that's 434 bytes
            # chop the start off.
            new_file = path[:-4]+'_fixed.syx'
            with open(path, 'rb') as f:
                s = f.read()
            start = s.find(b'\xf0\x00')
            end = s.find(b'\xf7')+1
            if (end - start) == 434:
                new_content = s[start:end]
                fixed = open(new_file, 'wb')
                fixed.write(new_content)
                fixed.close()
                return new_file
            else:
                print(error_msg)
                return False
    else:
        return path
